// utils/pomodoroManager.js
const { EmbedBuilder } = require("discord.js");
const User = require("../database/models/User");
const StudySession = require("../database/models/StudySession");
const Goal = require("../database/models/Goal");
const ActiveSession = require("../database/models/ActiveSession"); // Novo modelo
const config = require("../config/config");

// Cache local para armazenar as sess√µes ativas (para desempenho)
const memoryCache = new Map();

class PomodoroManager {
  constructor() {
    this.pomodoro = config.pomodoro;
  }

  /**
   * Carrega sess√µes ativas do banco de dados (ap√≥s rein√≠cio do bot)
   * @returns {Promise<void>}
   */
  async loadActiveSessions() {
    try {
      console.log("Carregando sess√µes de pomodoro ativas do banco de dados...");
      const activeSessions = await ActiveSession.find({
        sessionType: "pomodoro",
      });

      if (activeSessions.length === 0) {
        console.log(
          "Nenhuma sess√£o de pomodoro ativa encontrada no banco de dados."
        );
        return;
      }

      console.log(
        `Encontradas ${activeSessions.length} sess√µes de pomodoro ativas.`
      );

      // Reconstruir sess√µes em mem√≥ria e reiniciar timers
      for (const dbSession of activeSessions) {
        try {
          // Recuperar informa√ß√µes complementares
          const studySession = await StudySession.findById(
            dbSession.studySessionId
          );
          if (!studySession) {
            console.log(
              `Sess√£o de estudo ${dbSession.studySessionId} n√£o encontrada. Removendo sess√£o ativa.`
            );
            await ActiveSession.findByIdAndRemove(dbSession._id);
            continue;
          }

          // Calcular tempo restante ajustado
          const now = new Date();
          let timeLeftMs = dbSession.timeLeft;

          // Se estiver pausado, o tempo permanece o mesmo
          // Se n√£o estiver pausado, ajustar o tempo com base no tempo passado desde a √∫ltima atualiza√ß√£o
          if (!dbSession.paused && dbSession.lastUpdated) {
            const elapsedSinceUpdate = now - dbSession.lastUpdated;
            timeLeftMs = Math.max(0, timeLeftMs - elapsedSinceUpdate);
          }

          // Criar objeto de estado na mem√≥ria
          const sessionState = {
            sessionId: studySession._id,
            activeSessionId: dbSession._id,
            userId: dbSession.userId,
            username: dbSession.metadata?.username || "Usu√°rio",
            serverChannelId: dbSession.metadata?.serverChannelId,
            dmChannelId: dbSession.metadata?.dmChannelId,
            subject: dbSession.subject,
            goalId: dbSession.goalId,
            currentCycle: dbSession.currentCycle,
            status: dbSession.status,
            pomodorosCompleted: dbSession.pomodorosCompleted,
            timer: null,
            startTime: dbSession.startTime,
            timeLeft: timeLeftMs / 60000, // Converter para minutos
            paused: dbSession.paused,
            pendingRestore: true, // Marcar para restaura√ß√£o completa quando o client estiver dispon√≠vel
          };

          // Adicionar ao cache em mem√≥ria
          memoryCache.set(dbSession.userId, sessionState);

          console.log(
            `Restaurada sess√£o para usu√°rio ${dbSession.userId} (${sessionState.username})`
          );
        } catch (err) {
          console.error(`Erro ao restaurar sess√£o ${dbSession._id}:`, err);
        }
      }
    } catch (error) {
      console.error("Erro ao carregar sess√µes ativas:", error);
    }
  }

  /**
   * Completa a restaura√ß√£o das sess√µes quando o client est√° dispon√≠vel
   * @param {Object} client - Cliente Discord.js
   * @returns {Promise<void>}
   */
  async completeSessionsRestore(client) {
    for (const [userId, state] of memoryCache.entries()) {
      if (state.pendingRestore) {
        try {
          // Buscar canais
          let dmChannel;
          try {
            const user = await client.users.fetch(userId);
            if (user) {
              dmChannel = await user.createDM();
            }
          } catch (err) {
            console.warn(
              `N√£o foi poss√≠vel criar canal DM para usu√°rio ${userId}:`,
              err.message
            );
          }

          let serverChannel;
          if (state.serverChannelId) {
            try {
              serverChannel = await client.channels.fetch(
                state.serverChannelId
              );
            } catch (err) {
              console.warn(
                `N√£o foi poss√≠vel buscar canal do servidor ${state.serverChannelId}:`,
                err.message
              );
            }
          }

          // Atualizar estado com canais
          state.dmChannel = dmChannel;
          state.serverChannel = serverChannel;

          // Reiniciar timer se a sess√£o n√£o estiver pausada
          if (!state.paused && state.timeLeft > 0) {
            this._startTimer(state);

            // Notificar usu√°rio que sess√£o foi restaurada
            if (dmChannel) {
              const embed = new EmbedBuilder()
                .setTitle("üîÑ Sess√£o Pomodoro Restaurada")
                .setDescription(
                  "O bot foi reiniciado, mas sua sess√£o foi restaurada automaticamente."
                )
                .setColor("#3498db")
                .addFields(
                  {
                    name: "Status",
                    value:
                      state.status === "work"
                        ? "Trabalhando üí™"
                        : state.status === "shortBreak"
                        ? "Pausa Curta ‚òï"
                        : "Pausa Longa üßò",
                    inline: true,
                  },
                  {
                    name: "Tempo Restante",
                    value: `${Math.ceil(state.timeLeft)} minutos`,
                    inline: true,
                  },
                  {
                    name: "Pomodoros Completos",
                    value: `${state.pomodorosCompleted}`,
                    inline: true,
                  }
                );

              await dmChannel
                .send({ embeds: [embed] })
                .catch((err) =>
                  console.warn(
                    `Erro ao enviar mensagem de restaura√ß√£o para ${userId}:`,
                    err.message
                  )
                );
            }
          }

          // Remover flag de pend√™ncia
          state.pendingRestore = false;

          console.log(
            `Restaura√ß√£o de sess√£o finalizada para usu√°rio ${userId}`
          );
        } catch (err) {
          console.error(
            `Erro ao completar restaura√ß√£o para usu√°rio ${userId}:`,
            err
          );
        }
      }
    }
  }

  /**
   * Inicia uma nova sess√£o de pomodoro
   * @param {string} userId - ID do usu√°rio no Discord
   * @param {string} username - Nome do usu√°rio
   * @param {object} serverChannel - Canal do servidor onde o comando foi executado
   * @param {object} dmChannel - Canal de DM para enviar notifica√ß√µes
   * @param {string} subject - Assunto de estudo
   * @param {string} goalId - ID da meta associada (opcional)
   */
  async startPomodoro(
    userId,
    username,
    serverChannel,
    dmChannel,
    subject = "Geral",
    goalId = null
  ) {
    // Verificar se j√° existe uma sess√£o ativa no banco de dados ou cache
    if (memoryCache.has(userId)) {
      return {
        success: false,
        message: "Voc√™ j√° tem uma sess√£o de estudo ativa!",
      };
    }

    const existingSession = await ActiveSession.findOne({
      userId: userId,
      sessionType: "pomodoro",
    });

    if (existingSession) {
      // Se encontrou no banco mas n√£o no cache, remover do banco (sess√£o √≥rf√£)
      await ActiveSession.findByIdAndRemove(existingSession._id);
      console.log(`Removida sess√£o √≥rf√£ para usu√°rio ${userId}`);
    }

    // Obter ou criar usu√°rio
    let user = await User.findOne({ discordId: userId });
    if (!user) {
      user = new User({
        discordId: userId,
        username: username,
      });
      await user.save();
    }

    // Criar nova sess√£o de estudo
    const studySession = new StudySession({
      userId: userId,
      startTime: new Date(),
      type: "pomodoro",
      subject: subject,
    });
    await studySession.save();

    // Salvar metadados √∫teis para restaura√ß√£o
    const sessionMetadata = {
      username: username,
      serverChannelId: serverChannel?.id,
      dmChannelId: dmChannel?.id,
    };

    // Criar sess√£o ativa no banco de dados
    const activeSession = new ActiveSession({
      userId: userId,
      sessionType: "pomodoro",
      studySessionId: studySession._id,
      subject: subject,
      startTime: new Date(),
      status: "work",
      timeLeft: this.pomodoro.workTime,
      goalId: goalId,
      metadata: sessionMetadata,
      lastUpdated: new Date(),
    });

    await activeSession.save();

    // Configura√ß√£o do pomodoro em mem√≥ria
    const pomodoroState = {
      sessionId: studySession._id,
      activeSessionId: activeSession._id,
      userId: userId,
      username: username,
      serverChannel: serverChannel,
      dmChannel: dmChannel,
      subject: subject,
      goalId: goalId,
      currentCycle: 1,
      status: "work", // 'work', 'shortBreak', 'longBreak'
      pomodorosCompleted: 0,
      timer: null,
      startTime: new Date(),
      endTime: null,
      timeLeft: this.pomodoro.workTime / 60000, // Convertendo para minutos para exibi√ß√£o
      paused: false,
    };

    // Iniciar o primeiro timer de trabalho
    this._startTimer(pomodoroState);

    // Adicionar √† cache em mem√≥ria
    memoryCache.set(userId, pomodoroState);

    // Enviar mensagem inicial
    const embed = new EmbedBuilder()
      .setTitle("üçÖ Pomodoro Iniciado!")
      .setDescription(
        `Sess√£o de estudo iniciada!\nAssunto: ${subject}\nFoco por ${
          this.pomodoro.workTime / 60000
        } minutos.`
      )
      .setColor("#FF6347")
      .addFields(
        {
          name: "Ciclo atual",
          value: `${pomodoroState.currentCycle}/${this.pomodoro.longBreakInterval}`,
          inline: true,
        },
        { name: "Status", value: "Trabalhando üí™", inline: true },
        { name: "Pomodoros Completos", value: "0", inline: true }
      )
      .setFooter({
        text: "Use /pomodoro pause para pausar e /pomodoro stop para encerrar",
      });

    try {
      await dmChannel.send({ embeds: [embed] });
    } catch (error) {
      console.error("Erro ao enviar mensagem para DM:", error);
      // Tentar enviar no canal do servidor como fallback
      try {
        await serverChannel.send({
          content: `${username}, n√£o foi poss√≠vel enviar mensagens por DM. Verifique suas configura√ß√µes de privacidade.`,
          ephemeral: true,
        });
      } catch (err) {
        console.error("Erro ao enviar mensagem de fallback:", err);
      }

      // Mesmo com erro de DM, permitimos que a sess√£o continue
    }

    return {
      success: true,
      sessionId: studySession._id,
      message: "Sess√£o de pomodoro iniciada com sucesso!",
    };
  }

  /**
   * Inicia o timer para o estado atual e atualiza o banco de dados
   * @param {object} state - Estado do pomodoro
   */
  _startTimer(state) {
    let duration;

    switch (state.status) {
      case "work":
        duration = this.pomodoro.workTime;
        break;
      case "shortBreak":
        duration = this.pomodoro.shortBreak;
        break;
      case "longBreak":
        duration = this.pomodoro.longBreak;
        break;
    }

    state.timeLeft = duration / 60000; // Convertendo para minutos para facilitar a exibi√ß√£o

    // Limpar timer anterior se existir
    if (state.timer) {
      clearInterval(state.timer);
    }

    // Atualizar no banco de dados
    this._updateSessionState(state).catch((err) =>
      console.error("Erro ao atualizar estado da sess√£o:", err)
    );

    // Iniciar novo timer
    const startTime = Date.now();
    state.timer = setInterval(async () => {
      const elapsed = Date.now() - startTime;
      state.timeLeft = Math.max(0, (duration - elapsed) / 60000);

      // Atualizar banco de dados periodicamente (a cada 30 segundos)
      if (elapsed % 30000 < 1000) {
        await this._updateSessionState(state).catch((err) =>
          console.error("Erro ao atualizar estado da sess√£o:", err)
        );
      }

      // Verificar se o timer acabou
      if (state.timeLeft <= 0) {
        clearInterval(state.timer);
        await this._handleTimerEnd(state);
      }
    }, 1000);
  }

  /**
   * Atualiza o estado da sess√£o no banco de dados
   * @param {object} state - Estado do pomodoro
   * @returns {Promise<void>}
   */
  async _updateSessionState(state) {
    try {
      await ActiveSession.findByIdAndUpdate(state.activeSessionId, {
        status: state.status,
        timeLeft: state.timeLeft * 60000, // Converter minutos para ms
        currentCycle: state.currentCycle,
        pomodorosCompleted: state.pomodorosCompleted,
        paused: state.paused,
        pausedAt: state.paused ? new Date() : null,
        lastUpdated: new Date(),
      });
    } catch (error) {
      console.error("Erro ao atualizar sess√£o no banco de dados:", error);
      throw error;
    }
  }

  /**
   * Lidar com o fim de um timer
   * @param {object} state - Estado do pomodoro
   */
  async _handleTimerEnd(state) {
    try {
      switch (state.status) {
        case "work":
          // Incrementar pomodoros completos
          state.pomodorosCompleted += 1;

          // Atualizar sess√£o de estudo
          await StudySession.findByIdAndUpdate(state.sessionId, {
            pomodorosCompleted: state.pomodorosCompleted,
          });

          // Atualizar usu√°rio
          const user = await User.findOne({ discordId: state.userId });
          user.completedPomodoros += 1;

          // Adicionar tempo √† meta se existir
          if (state.goalId) {
            const goal = await Goal.findById(state.goalId);
            if (goal) {
              const workTimeMinutes = this.pomodoro.workTime / 60000;
              const goalCompleted = goal.addTime(workTimeMinutes);
              await goal.save();

              // Se a meta foi completada, dar XP extra
              if (goalCompleted) {
                await user.addXP(config.levels.goalCompletionXP, config.levels);

                // Notificar sobre a conclus√£o da meta
                const goalEmbed = new EmbedBuilder()
                  .setTitle("üéØ Meta Conclu√≠da!")
                  .setDescription(
                    `Parab√©ns! Voc√™ concluiu a meta: **${goal.title}**`
                  )
                  .setColor("#32CD32");

                await this._safelySendDM(state.dmChannel, {
                  embeds: [goalEmbed],
                });
              }
            }
          }

          // Dar XP pelo pomodoro completo
          await user.addXP(config.levels.studySessionXP / 2, config.levels);
          await user.save();

          // Verificar se √© hora de uma pausa longa
          if (
            state.pomodorosCompleted % this.pomodoro.longBreakInterval ===
            0
          ) {
            state.status = "longBreak";

            const embed = new EmbedBuilder()
              .setTitle("üçµ Hora da Pausa Longa!")
              .setDescription(
                `Voc√™ completou ${
                  state.pomodorosCompleted
                } pomodoros! Tire um descanso de ${
                  this.pomodoro.longBreak / 60000
                } minutos.`
              )
              .setColor("#4169E1")
              .addFields(
                {
                  name: "Pomodoros Completos",
                  value: `${state.pomodorosCompleted}`,
                  inline: true,
                },
                { name: "Status", value: "Pausa Longa üßò", inline: true }
              );

            await this._safelySendDM(state.dmChannel, { embeds: [embed] });
          } else {
            state.status = "shortBreak";

            const embed = new EmbedBuilder()
              .setTitle("‚òï Hora da Pausa!")
              .setDescription(
                `Bom trabalho! Tire um descanso de ${
                  this.pomodoro.shortBreak / 60000
                } minutos.`
              )
              .setColor("#20B2AA")
              .addFields(
                {
                  name: "Pomodoros Completos",
                  value: `${state.pomodorosCompleted}`,
                  inline: true,
                },
                { name: "Status", value: "Pausa Curta ‚òï", inline: true }
              );

            await this._safelySendDM(state.dmChannel, { embeds: [embed] });
          }
          break;

        case "shortBreak":
        case "longBreak":
          state.status = "work";
          state.currentCycle += 1;

          const embed = new EmbedBuilder()
            .setTitle("üçÖ De Volta ao Trabalho!")
            .setDescription(
              `Pausa conclu√≠da! Hora de focar por mais ${
                this.pomodoro.workTime / 60000
              } minutos.`
            )
            .setColor("#FF6347")
            .addFields(
              {
                name: "Ciclo atual",
                value: `${state.currentCycle}/${this.pomodoro.longBreakInterval}`,
                inline: true,
              },
              { name: "Status", value: "Trabalhando üí™", inline: true },
              {
                name: "Pomodoros Completos",
                value: `${state.pomodorosCompleted}`,
                inline: true,
              }
            );

          await this._safelySendDM(state.dmChannel, { embeds: [embed] });
          break;
      }

      // Atualizar banco de dados
      await this._updateSessionState(state);

      // Iniciar pr√≥ximo timer
      this._startTimer(state);
    } catch (error) {
      console.error("Erro ao processar fim de timer:", error);
      // Tentar continuar mesmo com erro
      this._startTimer(state);
    }
  }

  /**
   * M√©todo auxiliar para enviar mensagens para DM com seguran√ßa
   * @param {object} channel - Canal para enviar a mensagem
   * @param {object} messageOptions - Op√ß√µes da mensagem
   */
  async _safelySendDM(channel, messageOptions) {
    try {
      if (channel) {
        await channel.send(messageOptions);
      }
    } catch (error) {
      console.error("Erro ao enviar mensagem para DM:", error);
      // Silenciosamente falha, n√£o queremos que o pomodoro pare por causa de erros de DM
    }
  }

  /**
   * Pausa a sess√£o de pomodoro
   * @param {string} userId - ID do usu√°rio
   */
  async pausePomodoro(userId) {
    const session = memoryCache.get(userId);

    if (!session) {
      return {
        success: false,
        message: "Voc√™ n√£o tem uma sess√£o de pomodoro ativa!",
      };
    }

    if (session.paused) {
      return {
        success: false,
        message: "Sua sess√£o j√° est√° pausada!",
      };
    }

    clearInterval(session.timer);
    session.timer = null;
    session.paused = true;

    // Atualizar no banco de dados
    await this._updateSessionState(session);

    const embed = new EmbedBuilder()
      .setTitle("‚è∏Ô∏è Pomodoro Pausado")
      .setDescription(
        `Sua sess√£o de pomodoro foi pausada. Use /pomodoro resume para continuar.`
      )
      .setColor("#FFA500")
      .addFields(
        {
          name: "Tempo Restante",
          value: `${Math.ceil(session.timeLeft)} minutos`,
          inline: true,
        },
        {
          name: "Status",
          value:
            session.status === "work"
              ? "Trabalhando (Pausado)"
              : "Pausa (Pausado)",
          inline: true,
        }
      );

    await this._safelySendDM(session.dmChannel, { embeds: [embed] });

    return {
      success: true,
      message: "Sess√£o de pomodoro pausada com sucesso!",
    };
  }

  /**
   * Retoma a sess√£o de pomodoro
   * @param {string} userId - ID do usu√°rio
   */
  async resumePomodoro(userId) {
    const session = memoryCache.get(userId);

    if (!session) {
      return {
        success: false,
        message: "Voc√™ n√£o tem uma sess√£o de pomodoro para retomar!",
      };
    }

    if (!session.paused) {
      return {
        success: false,
        message: "Sua sess√£o de pomodoro n√£o est√° pausada!",
      };
    }

    session.paused = false;

    // Atualizar no banco de dados
    await this._updateSessionState(session);

    // Continuar o timer de onde parou
    const remainingTime = session.timeLeft * 60000; // Converter para ms
    const startTime = Date.now();
    session.timer = setInterval(async () => {
      const elapsed = Date.now() - startTime;
      session.timeLeft = Math.max(0, (remainingTime - elapsed) / 60000);

      // Atualizar banco de dados periodicamente (a cada 30 segundos)
      if (elapsed % 30000 < 1000) {
        await this._updateSessionState(session).catch((err) =>
          console.error("Erro ao atualizar estado da sess√£o:", err)
        );
      }

      if (session.timeLeft <= 0) {
        clearInterval(session.timer);
        await this._handleTimerEnd(session);
      }
    }, 1000);

    const embed = new EmbedBuilder()
      .setTitle("‚ñ∂Ô∏è Pomodoro Retomado")
      .setDescription(`Sua sess√£o de pomodoro foi retomada.`)
      .setColor("#32CD32")
      .addFields(
        {
          name: "Tempo Restante",
          value: `${Math.ceil(session.timeLeft)} minutos`,
          inline: true,
        },
        {
          name: "Status",
          value: session.status === "work" ? "Trabalhando üí™" : "Em Pausa üßò",
          inline: true,
        }
      );

    await this._safelySendDM(session.dmChannel, { embeds: [embed] });

    return {
      success: true,
      message: "Sess√£o de pomodoro retomada com sucesso!",
    };
  }

  /**
   * Encerra a sess√£o de pomodoro
   * @param {string} userId - ID do usu√°rio
   */
  async stopPomodoro(userId) {
    const session = memoryCache.get(userId);

    if (!session) {
      return {
        success: false,
        message: "Voc√™ n√£o tem uma sess√£o de pomodoro ativa!",
      };
    }

    // Limpar timer
    if (session.timer) {
      clearInterval(session.timer);
      session.timer = null;
    }

    // Calcular dura√ß√£o efetiva
    const now = new Date();
    const duration = Math.floor((now - session.startTime) / 60000); // Converter para minutos

    try {
      // Remover do banco de dados
      await ActiveSession.findByIdAndRemove(session.activeSessionId);

      // Atualizar sess√£o de estudo
      await StudySession.findByIdAndUpdate(session.sessionId, {
        endTime: now,
        duration: duration,
        completed: true,
        pomodorosCompleted: session.pomodorosCompleted,
      });

      // Atualizar usu√°rio
      const user = await User.findOne({ discordId: session.userId });
      if (user) {
        user.totalStudyTime += duration;
        user.totalSessions += 1;
        user.completedPomodoros += session.pomodorosCompleted;

        // Atualizar streak
        user.updateStreak();

        // Dar XP pela sess√£o completa
        const xpGained = Math.min(100, duration); // Limitar a 100 XP
        let leveledUp = false;

        if (user.addXP) {
          leveledUp = await user.addXP(xpGained, config.levels);
        } else {
          // M√©todo alternativo caso o m√©todo addXP n√£o exista
          user.xp += xpGained;
          if (user.xp >= user.xpToNextLevel) {
            user.level += 1;
            user.xp -= user.xpToNextLevel;
            user.xpToNextLevel = Math.floor(
              config.levels.baseXP *
                Math.pow(config.levels.growthFactor, user.level - 1)
            );
            leveledUp = true;
          }
        }

        await user.save();

        // Atualizar meta se houver
        if (session.goalId) {
          const goal = await Goal.findById(session.goalId);
          if (goal) {
            goal.addTime(duration);
            await goal.save();
          }
        }

        // Enviar mensagem de conclus√£o
        const completionEmbed = new EmbedBuilder()
          .setTitle("‚úÖ Sess√£o Pomodoro Conclu√≠da")
          .setDescription(`${session.username} encerrou a sess√£o de pomodoro!`)
          .setColor("#2ecc71")
          .addFields(
            { name: "Assunto", value: session.subject, inline: true },
            {
              name: "Pomodoros Completos",
              value: `${session.pomodorosCompleted}`,
              inline: true,
            },
            {
              name: "Dura√ß√£o Total",
              value: `${duration} minutos`,
              inline: true,
            },
            { name: "XP Ganho", value: `${xpGained}`, inline: true }
          );

        if (leveledUp) {
          completionEmbed.addFields({
            name: "üéâ Subiu de N√≠vel!",
            value: `${session.username} alcan√ßou o n√≠vel ${user.level}!`,
          });
        }

        await this._safelySendDM(session.dmChannel, {
          embeds: [completionEmbed],
        });

        // Remover da lista de sess√µes ativas
        memoryCache.delete(userId);

        return {
          success: true,
          message: "Sess√£o de pomodoro encerrada com sucesso!",
        };
      } else {
        console.error("Usu√°rio n√£o encontrado ao encerrar sess√£o de pomodoro");
        return {
          success: false,
          message: "Erro ao encerrar sess√£o: usu√°rio n√£o encontrado",
        };
      }
    } catch (error) {
      console.error("Erro ao encerrar sess√£o de pomodoro:", error);
      return {
        success: false,
        message: "Ocorreu um erro ao encerrar a sess√£o de pomodoro.",
      };
    } finally {
      // Garantir que o usu√°rio seja removido da lista mesmo se houver erros
      memoryCache.delete(userId);
    }
  }

  /**
   * Obt√©m a sess√£o ativa de um usu√°rio
   * @param {string} userId - ID do usu√°rio
   * @returns {object|null} Sess√£o ativa ou null se n√£o existir
   */
  getActiveSession(userId) {
    const session = memoryCache.get(userId);
    if (!session) return null;

    // Calcular minutos restantes para exibi√ß√£o
    const timeLeftMinutes = Math.ceil(session.timeLeft);

    return {
      userId: session.userId,
      username: session.username,
      subject: session.subject,
      status: session.status,
      pomodorosCompleted: session.pomodorosCompleted,
      currentCycle: session.currentCycle,
      paused: session.paused,
      startTime: session.startTime,
      timeLeft: timeLeftMinutes,
    };
  }

  /**
   * Obt√©m todas as sess√µes de pomodoro ativas
   * @returns {Array} Array de sess√µes ativas
   */
  getAllActiveSessions() {
    const sessions = [];

    memoryCache.forEach((session, userId) => {
      sessions.push({
        userId: userId,
        username: session.username,
        subject: session.subject,
        status: session.status,
        pomodorosCompleted: session.pomodorosCompleted,
        paused: session.paused,
        started: session.serverChannel?.type === 1 ? "DM" : "Servidor",
      });
    });

    return sessions;
  }

  /**
   * Limpa sess√µes √≥rf√£s ou expiradas do banco de dados
   * @returns {Promise<number>} N√∫mero de sess√µes removidas
   */
  async cleanOrphanedSessions() {
    try {
      // Remover sess√µes mais antigas que 12 horas
      const cutoff = new Date(Date.now() - 12 * 60 * 60 * 1000);

      const result = await ActiveSession.deleteMany({
        sessionType: "pomodoro",
        lastUpdated: { $lt: cutoff },
      });

      console.log(
        `Limpeza de sess√µes: ${result.deletedCount} sess√µes antigas removidas`
      );
      return result.deletedCount;
    } catch (error) {
      console.error("Erro ao limpar sess√µes √≥rf√£s:", error);
      return 0;
    }
  }

  /**
   * M√©todo de limpeza espec√≠fico para testes
   * @param {boolean} cacheOnly - Se true, limpa apenas o cache sem afetar o banco
   * @returns {Promise<void>}
   */
  async cleanupForTests(cacheOnly = false) {
    try {
      // Limpar todos os timers em mem√≥ria
      for (const [userId, state] of memoryCache.entries()) {
        if (state.timer) {
          clearInterval(state.timer);
          state.timer = null;
        }
      }

      // Limpar o cache em mem√≥ria
      memoryCache.clear();

      // Limpar tamb√©m no banco de dados, se solicitado
      if (!cacheOnly) {
        await ActiveSession.deleteMany({ sessionType: "pomodoro" });
      }

      console.log("Limpeza de sess√µes para testes conclu√≠da");
    } catch (error) {
      console.error("Erro durante limpeza para testes:", error);
    }
  }
}

// Exportar uma inst√¢ncia √∫nica
module.exports = new PomodoroManager();
